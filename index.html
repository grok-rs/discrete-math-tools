<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Venn Diagram Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f9fafb;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 320px;
            background: white;
            border-right: 1px solid #e5e7eb;
            padding: 24px;
            overflow-y: auto;
        }

        h1 {
            font-size: 20px;
            margin-bottom: 24px;
            color: #111827;
        }

        .section {
            margin-bottom: 24px;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .diagram-type-selector {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
        }

        .diagram-type-selector label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            color: #374151;
            cursor: pointer;
        }

        .diagram-type-selector input[type="radio"] {
            cursor: pointer;
        }

        .input-group {
            margin-bottom: 12px;
        }

        input[type="text"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 8px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #6366f1;
            color: white;
            width: 100%;
        }

        .btn-primary:hover {
            background: #4f46e5;
        }

        .operations {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .op-button {
            height: 56px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            gap: 2px;
        }

        .op-button .symbol {
            font-size: 28px;
            font-weight: normal;
            line-height: 1;
        }

        .op-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .op-union { background: #22c55e; }
        .op-intersection { background: #6366f1; }
        .op-difference { background: #ef4444; }
        .op-symmetric { background: #fb923c; }
        .op-complement { background: #8b5cf6; }

        .set-list {
            list-style: none;
        }

        .set-item {
            padding: 12px;
            background: #f9fafb;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .set-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .set-info {
            flex: 1;
            font-size: 14px;
        }

        .set-name {
            font-weight: 600;
            color: #111827;
        }

        .set-elements {
            color: #6b7280;
            font-size: 13px;
            margin-top: 2px;
        }

        .btn-remove {
            background: #ef4444;
            color: white;
            padding: 4px 8px;
            font-size: 12px;
        }

        .main-canvas {
            flex: 1;
            position: relative;
            background: white;
        }

        canvas {
            display: block;
        }

        .tooltip {
            position: absolute;
            background: rgba(30, 30, 40, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            white-space: pre-line;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            max-width: 300px;
            word-wrap: break-word;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 12px 24px;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            font-size: 14px;
        }

        .examples {
            font-size: 12px;
            color: #6b7280;
            line-height: 1.6;
        }

        .examples code {
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        /* Cheat Sheet Styles */
        .cheat-sheet-container {
            margin-top: 8px;
        }

        details {
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 0;
            background: white;
        }

        summary {
            cursor: pointer;
            padding: 10px 12px;
            font-weight: 600;
            font-size: 14px;
            color: #374151;
            user-select: none;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary::before {
            content: '▶';
            font-size: 10px;
            transition: transform 0.2s;
        }

        details[open] summary::before {
            transform: rotate(90deg);
        }

        summary:hover {
            background: #f9fafb;
        }

        .cheat-sheet-content {
            padding: 12px;
            max-height: 400px;
            overflow-y: auto;
            border-top: 1px solid #e5e7eb;
        }

        .formula-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .formula-table th {
            background: #f9fafb;
            padding: 8px 6px;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            position: sticky;
            top: 0;
        }

        .formula-table td {
            padding: 6px;
            border-bottom: 1px solid #f3f4f6;
            vertical-align: top;
        }

        .formula-table tr:last-child td {
            border-bottom: none;
        }

        .formula-table .formula {
            font-family: 'Courier New', monospace;
            color: #6366f1;
            font-size: 13px;
        }

        .formula-table .law-name {
            font-weight: 600;
            color: #111827;
            margin-bottom: 4px;
        }

        .formula-table .law-name-uk {
            font-weight: 600;
            color: #111827;
            margin-bottom: 4px;
        }

        /* Language Switcher Styles */
        .language-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            padding: 8px;
            background: #f9fafb;
            border-radius: 8px;
            justify-content: center;
        }

        .language-selector button {
            flex: 1;
            padding: 6px 12px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s;
        }

        .language-selector button:hover {
            background: #f3f4f6;
        }

        .language-selector button.active {
            background: #6366f1;
            color: white;
            border-color: #6366f1;
        }

        /* ===== RESPONSIVE DESIGN ===== */

        /* Mobile devices (< 768px) */
        @media (max-width: 767px) {
            body {
                flex-direction: column;
                overflow-y: auto;
                height: auto;
                min-height: 100vh;
            }

            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e5e7eb;
                padding: 16px;
                max-height: none;
                overflow-y: visible;
            }

            h1 {
                font-size: 18px;
                margin-bottom: 16px;
            }

            .section {
                margin-bottom: 16px;
            }

            .section-title {
                font-size: 13px;
            }

            /* Single column operation buttons for easier touch */
            .operations {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            /* Larger touch targets */
            .op-button {
                height: 64px;
            }

            button {
                padding: 12px 20px;
                font-size: 16px;
                min-height: 44px; /* iOS recommended minimum */
            }

            .btn-remove {
                padding: 8px 12px;
                font-size: 14px;
            }

            input[type="text"] {
                font-size: 16px; /* Prevent zoom on iOS */
                padding: 10px 12px;
            }

            .main-canvas {
                min-height: 400px;
                flex: none;
                height: 50vh;
            }

            .status-bar {
                position: relative;
                padding: 12px 16px;
                font-size: 13px;
            }

            .examples {
                font-size: 11px;
            }

            .set-item {
                padding: 10px;
            }

            .tooltip {
                font-size: 12px;
                max-width: 250px;
            }

            /* Mobile cheat sheet adjustments */
            .formula-table {
                font-size: 11px;
            }

            .formula-table th {
                padding: 6px 4px;
                font-size: 12px;
            }

            .formula-table td {
                padding: 4px;
            }

            .formula-table .formula {
                font-size: 11px;
            }

            .cheat-sheet-content {
                max-height: 300px;
                padding: 8px;
            }

            summary {
                font-size: 13px;
                padding: 8px 10px;
            }
        }

        /* Tablet devices (768px - 1023px) */
        @media (min-width: 768px) and (max-width: 1023px) {
            .sidebar {
                width: 280px;
                padding: 20px;
            }

            h1 {
                font-size: 19px;
                margin-bottom: 20px;
            }

            .section {
                margin-bottom: 20px;
            }

            .op-button {
                height: 60px;
            }

            button {
                padding: 10px 18px;
            }
        }

        /* Large desktop (1440px+) */
        @media (min-width: 1440px) {
            .sidebar {
                width: 360px;
                padding: 28px;
            }

            h1 {
                font-size: 22px;
                margin-bottom: 28px;
            }

            .section {
                margin-bottom: 28px;
            }

            .section-title {
                font-size: 15px;
            }

            button {
                font-size: 15px;
            }

            .tooltip {
                font-size: 14px;
            }
        }

        /* Landscape mobile phones */
        @media (max-width: 767px) and (orientation: landscape) {
            .sidebar {
                max-height: 40vh;
                overflow-y: auto;
            }

            .main-canvas {
                height: 60vh;
            }
        }

        /* Print styles */
        @media print {
            .sidebar {
                display: none;
            }

            .main-canvas {
                width: 100%;
            }

            .status-bar {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <h1 data-i18n="title">Venn Diagram Builder</h1>

        <div class="language-selector">
            <button onclick="setLanguage('en')" id="lang-en" class="active">English</button>
            <button onclick="setLanguage('uk')" id="lang-uk">Українська</button>
        </div>

        <div class="diagram-type-selector">
            <label>
                <input type="radio" name="diagramType" value="venn" checked onchange="changeDiagramType('venn')">
                <span data-i18n="vennDiagram">Venn Diagram</span>
            </label>
            <label>
                <input type="radio" name="diagramType" value="euler" onchange="changeDiagramType('euler')">
                <span data-i18n="eulerDiagram">Euler Diagram</span>
            </label>
        </div>

        <div class="section">
            <div class="section-title" data-i18n="input">Input</div>
            <div class="input-group">
                <input type="text" id="inputField" data-i18n-placeholder="inputPlaceholder" placeholder="e.g., A={1,2,3} or A ∪ B">
                <button class="btn-primary" onclick="executeInput()" data-i18n="execute">Execute</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title" data-i18n="quickOperations">Quick Operations</div>
            <div class="operations">
                <button class="op-button op-union" onclick="insertOperation('union')">
                    <span class="symbol">∪</span>
                    <span data-i18n="union">Union</span>
                </button>
                <button class="op-button op-intersection" onclick="insertOperation('intersection')">
                    <span class="symbol">∩</span>
                    <span data-i18n="intersect">Intersect</span>
                </button>
                <button class="op-button op-difference" onclick="insertOperation('difference')">
                    <span class="symbol">\</span>
                    <span data-i18n="difference">Difference</span>
                </button>
                <button class="op-button op-symmetric" onclick="insertOperation('symmetric')">
                    <span class="symbol">△</span>
                    <span data-i18n="symDiff">Sym Diff</span>
                </button>
                <button class="op-button op-complement" onclick="insertOperation('complement')">
                    <span class="symbol">A̅</span>
                    <span data-i18n="complement">Complement</span>
                </button>
            </div>
        </div>

        <div class="section">
            <div class="section-title" data-i18n="sets">Sets</div>
            <ul class="set-list" id="setList"></ul>
            <div class="input-group">
                <input type="text" id="newSetName" data-i18n-placeholder="newSetNamePlaceholder" placeholder="New set name">
                <button class="btn-primary" onclick="addEmptySet()" data-i18n="addSet">+ Add Set</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title" data-i18n="examples">Examples</div>
            <div class="examples" id="examplesContent">
                Set definition:<br>
                <code>A={1,2,3}</code><br>
                Operations:<br>
                <code>A ∪ B</code> (union)<br>
                <code>A ∩ B</code> (intersection)<br>
                <code>A \ B</code> (difference)<br>
                <code>A̅</code> (complement)
            </div>
        </div>

        <div class="section">
            <div class="section-title" data-i18n="formulas">Formulas</div>
            <div class="cheat-sheet-container">
                <details>
                    <summary data-i18n="algebraOfSets">Algebra of Sets</summary>
                    <div class="cheat-sheet-content">
                        <table class="formula-table">
                            <tbody>
                                <tr>
                                    <td>
                                        <div class="law-name" data-i18n="identityLaws">Identity Laws</div>
                                        <div class="formula">A ∪ ∅ = A</div>
                                        <div class="formula">A ∩ U = A</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <div class="law-name" data-i18n="dominationLaws">Domination Laws</div>
                                        <div class="formula">A ∪ U = U</div>
                                        <div class="formula">A ∩ ∅ = ∅</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <div class="law-name" data-i18n="idempotentLaws">Idempotent Laws</div>
                                        <div class="formula">A ∪ A = A</div>
                                        <div class="formula">A ∩ A = A</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <div class="law-name" data-i18n="complementLaws">Complement Laws</div>
                                        <div class="formula">A ∪ A' = U</div>
                                        <div class="formula">A ∩ A' = ∅</div>
                                        <div class="formula">(A')' = A</div>
                                        <div class="formula">U' = ∅</div>
                                        <div class="formula">∅' = U</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <div class="law-name" data-i18n="commutativeLaws">Commutative Laws</div>
                                        <div class="formula">A ∪ B = B ∪ A</div>
                                        <div class="formula">A ∩ B = B ∩ A</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <div class="law-name" data-i18n="associativeLaws">Associative Laws</div>
                                        <div class="formula">A ∪ (B ∪ C) = (A ∪ B) ∪ C</div>
                                        <div class="formula">A ∩ (B ∩ C) = (A ∩ B) ∩ C</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <div class="law-name" data-i18n="distributiveLaws">Distributive Laws</div>
                                        <div class="formula">A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)</div>
                                        <div class="formula">A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <div class="law-name" data-i18n="deMorganLaws">De Morgan's Laws</div>
                                        <div class="formula">(A ∪ B)' = A' ∩ B'</div>
                                        <div class="formula">(A ∩ B)' = A' ∪ B'</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <div class="law-name" data-i18n="absorptionLaws">Absorption Laws</div>
                                        <div class="formula">A ∪ (A ∩ B) = A</div>
                                        <div class="formula">A ∩ (A ∪ B) = A</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <div class="law-name" data-i18n="differenceLaws">Difference</div>
                                        <div class="formula">A \ B = A ∩ B'</div>
                                        <div class="formula">A \ (B ∪ C) = (A \ B) ∩ (A \ C)</div>
                                        <div class="formula">A \ (B ∩ C) = (A \ B) ∪ (A \ C)</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <div class="law-name" data-i18n="symmetricDifferenceLaws">Symmetric Difference</div>
                                        <div class="formula">A △ B = (A \ B) ∪ (B \ A)</div>
                                        <div class="formula">A △ B = (A ∪ B) \ (A ∩ B)</div>
                                        <div class="formula">A △ B = B △ A</div>
                                        <div class="formula">A △ ∅ = A</div>
                                        <div class="formula">A △ A = ∅</div>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </details>
            </div>
        </div>
    </div>

    <div class="main-canvas">
        <canvas id="vennCanvas"></canvas>
        <div class="tooltip" id="tooltip"></div>
        <div class="status-bar" id="statusBar">Ready. Enter a set definition or operation.</div>
    </div>

    <script>
        'use strict';

        // ===================================================================
        // CONFIGURATION & CONSTANTS
        // ===================================================================

        const CONFIG = {
            MAX_SETS: 4,
            ELEMENT_DISPLAY_THRESHOLD: 5,
            ELEMENT_PREVIEW_COUNT: 3,
            CANVAS_PADDING: 40,
            LINE_WIDTH: {
                default: 2,
                diagonal: 1.5
            },
            FONT_SIZE: {
                label: 'bold 18px sans-serif',
                element: '14px sans-serif',
                result: '16px sans-serif'
            },
            HATCHING_SPACING: 8,
            DEBOUNCE_DELAY: 300,

            COLORS: {
                indigo: [99, 102, 241],
                pink: [236, 72, 153],
                green: [34, 197, 94],
                orange: [251, 146, 60]
            },

            OPERATION_SYMBOLS: {
                union: '∪',
                intersection: '∩',
                difference: '\\',
                symmetric: '△',
                complement: '\u0305'
            },

            OPERATION_COLORS: {
                union: 'rgb(16, 185, 129)',
                intersection: 'rgb(79, 70, 229)',
                difference: 'rgb(220, 38, 38)',
                symmetric: 'rgb(245, 124, 0)',
                complement: 'rgb(124, 58, 237)'
            },

            STATUS_COLORS: {
                success: '#22c55e',
                error: '#ef4444',
                info: '#6366f1',
                warning: '#fb923c',
                default: '#374151'
            },

            REGEX: {
                setDefinition: /^([A-Za-z]+)\s*=\s*\{([^}]*)\}$/,
                complement: /^([A-Za-z]+)['̅]$/,
                binaryOperation: /^([A-Za-z]+)\s*([∪∩\\△]|U)\s*([A-Za-z]+)$/,
                whitespace: /\s+/g
            }
        };

        // Translations
        const translations = {
            en: {
                title: "Venn Diagram Builder",
                vennDiagram: "Venn Diagram",
                eulerDiagram: "Euler Diagram",
                input: "Input",
                inputPlaceholder: "e.g., A={1,2,3} or A ∪ B",
                execute: "Execute",
                quickOperations: "Quick Operations",
                union: "Union",
                intersect: "Intersect",
                difference: "Difference",
                symDiff: "Sym Diff",
                complement: "Complement",
                sets: "Sets",
                newSetNamePlaceholder: "New set name",
                addSet: "+ Add Set",
                examples: "Examples",
                examplesContent: `Set definition:<br><code>A={1,2,3}</code><br>Operations:<br><code>A ∪ B</code> (union)<br><code>A ∩ B</code> (intersection)<br><code>A \\ B</code> (difference)<br><code>A̅</code> (complement)`,
                formulas: "Formulas",
                algebraOfSets: "Algebra of Sets",
                identityLaws: "Identity Laws",
                dominationLaws: "Domination Laws",
                idempotentLaws: "Idempotent Laws",
                complementLaws: "Complement Laws",
                commutativeLaws: "Commutative Laws",
                associativeLaws: "Associative Laws",
                distributiveLaws: "Distributive Laws",
                deMorganLaws: "De Morgan's Laws",
                absorptionLaws: "Absorption Laws",
                differenceLaws: "Difference",
                symmetricDifferenceLaws: "Symmetric Difference",
                readyStatus: "Ready. Enter a set definition or operation.",
                updatedSet: "Updated set",
                createdSet: "Created set",
                maxSets: "Maximum 4 sets allowed",
                setNotDefined: "not defined. Create it with",
                setsNotDefined: "not defined. Create them first.",
                removedSet: "Removed set",
                addedEmptySet: "Added empty set",
                setNameExists: "Set name already exists",
                invalidSyntax: "Invalid syntax. Examples: A={1,2,3} or A ∪ B or A̅",
                noChanges: "No changes to commit",
                only: "only"
            },
            uk: {
                title: "Конструктор діаграм Венна",
                vennDiagram: "Діаграма Венна",
                eulerDiagram: "Діаграма Ейлера",
                input: "Введення",
                inputPlaceholder: "напр., A={1,2,3} або A ∪ B",
                execute: "Виконати",
                quickOperations: "Швидкі операції",
                union: "Об'єднання",
                intersect: "Перетин",
                difference: "Різниця",
                symDiff: "Сим. різниця",
                complement: "Доповнення",
                sets: "Множини",
                newSetNamePlaceholder: "Назва нової множини",
                addSet: "+ Додати множину",
                examples: "Приклади",
                examplesContent: `Визначення множини:<br><code>A={1,2,3}</code><br>Операції:<br><code>A ∪ B</code> (об'єднання)<br><code>A ∩ B</code> (перетин)<br><code>A \\ B</code> (різниця)<br><code>A̅</code> (доповнення)`,
                formulas: "Формули",
                algebraOfSets: "Алгебра множин",
                identityLaws: "Закони тотожності",
                dominationLaws: "Закони домінування",
                idempotentLaws: "Закони ідемпотентності",
                complementLaws: "Закони доповнення",
                commutativeLaws: "Закони комутативності",
                associativeLaws: "Закони асоціативності",
                distributiveLaws: "Закони дистрибутивності",
                deMorganLaws: "Закони де Моргана",
                absorptionLaws: "Закони поглинання",
                differenceLaws: "Різниця множин",
                symmetricDifferenceLaws: "Симетрична різниця",
                readyStatus: "Готово. Введіть визначення множини або операцію.",
                updatedSet: "Оновлено множину",
                createdSet: "Створено множину",
                maxSets: "Максимум 4 множини дозволено",
                setNotDefined: "не визначена. Створіть її за допомогою",
                setsNotDefined: "не визначені. Створіть їх спочатку.",
                removedSet: "Видалено множину",
                addedEmptySet: "Додано порожню множину",
                setNameExists: "Назва множини вже існує",
                invalidSyntax: "Неправильний синтаксис. Приклади: A={1,2,3} або A ∪ B або A̅",
                noChanges: "Немає змін для фіксації",
                only: "тільки"
            }
        };

        // ===================================================================
        // UTILITIES MODULE
        // ===================================================================

        const Utils = (() => {
            /**
             * Format RGB color array as CSS string
             * @param {number[]} colorArray - RGB color array [r, g, b]
             * @returns {string} CSS rgb() string
             */
            const formatRgbColor = (colorArray) => `rgb(${colorArray.join(',')})`;

            /**
             * Format element list for display
             * @param {Array} elements - Array of elements
             * @param {number} threshold - Max elements to show before summarizing
             * @returns {string} Formatted element string
             */
            const formatElementList = (elements, threshold = CONFIG.ELEMENT_DISPLAY_THRESHOLD) => {
                if (elements.length === 0) return '∅';
                if (elements.length <= threshold) {
                    return `{${elements.join(', ')}}`;
                }
                return `{${elements.slice(0, CONFIG.ELEMENT_PREVIEW_COUNT).join(', ')}, ... (${elements.length} total)}`;
            };

            /**
             * Debounce function execution
             * @param {Function} func - Function to debounce
             * @param {number} delay - Delay in milliseconds
             * @returns {Function} Debounced function
             */
            const debounce = (func, delay = CONFIG.DEBOUNCE_DELAY) => {
                let timeoutId;
                return (...args) => {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => func(...args), delay);
                };
            };

            /**
             * Validate set name
             * @param {string} name - Set name to validate
             * @returns {{valid: boolean, error: string|null}}
             */
            const validateSetName = (name) => {
                if (!name || !name.trim()) {
                    return { valid: false, error: 'Set name cannot be empty' };
                }
                if (!/^[A-Za-z]+$/.test(name)) {
                    return { valid: false, error: 'Set name must contain only letters' };
                }
                return { valid: true, error: null };
            };

            /**
             * Get color by index from config
             * @param {number} index - Color index
             * @returns {number[]} RGB color array
             */
            const getColorByIndex = (index) => {
                const colorKeys = Object.keys(CONFIG.COLORS);
                const colorKey = colorKeys[index % colorKeys.length];
                return CONFIG.COLORS[colorKey];
            };

            /**
             * Check if point is inside circle
             * @param {number} x - Point x coordinate
             * @param {number} y - Point y coordinate
             * @param {{x: number, y: number, r: number}} circle - Circle object
             * @returns {boolean}
             */
            const isPointInCircle = (x, y, circle) => {
                const dx = x - circle.x;
                const dy = y - circle.y;
                return dx * dx + dy * dy <= circle.r * circle.r;
            };

            return {
                formatRgbColor,
                formatElementList,
                debounce,
                validateSetName,
                getColorByIndex,
                isPointInCircle
            };
        })();

        // ===================================================================
        // STATE MANAGER MODULE
        // ===================================================================

        const StateManager = (() => {
            // Private state
            let state = {
                sets: [],
                universalSet: new Set(),
                resultElements: null,
                resultDescription: '',
                hoveredRegion: null,
                currentOperation: null,
                diagramType: 'venn'
            };

            /**
             * Get current state (read-only copy)
             * @returns {Object} State object
             */
            const getState = () => ({ ...state });

            /**
             * Get sets array
             * @returns {Array}
             */
            const getSets = () => state.sets;

            /**
             * Get diagram type
             * @returns {string}
             */
            const getDiagramType = () => state.diagramType;

            /**
             * Set diagram type
             * @param {string} type - 'venn' or 'euler'
             */
            const setDiagramType = (type) => {
                state.diagramType = type;
            };

            /**
             * Update universal set (union of all sets)
             */
            const updateUniversalSet = () => {
                state.universalSet = new Set();
                state.sets.forEach(set => {
                    set.elements.forEach(elem => state.universalSet.add(elem));
                });
            };

            /**
             * Clear current operation state
             */
            const clearOperation = () => {
                state.currentOperation = null;
                state.resultElements = null;
                state.resultDescription = '';
            };

            /**
             * Set current operation
             * @param {Object} operation - Operation object
             * @param {Set} resultElements - Result elements
             * @param {string} description - Result description
             */
            const setOperation = (operation, resultElements, description) => {
                state.currentOperation = operation;
                state.resultElements = resultElements;
                state.resultDescription = description;
            };

            /**
             * Add new set
             * @param {string} name - Set name
             * @param {Array} elements - Array of elements
             * @returns {{success: boolean, error: string|null}}
             */
            const addSet = (name, elements = []) => {
                const validation = Utils.validateSetName(name);
                if (!validation.valid) {
                    return { success: false, error: validation.error };
                }

                if (state.sets.length >= CONFIG.MAX_SETS) {
                    return { success: false, error: `Maximum ${CONFIG.MAX_SETS} sets allowed` };
                }

                if (state.sets.find(s => s.name === name)) {
                    return { success: false, error: 'Set name already exists' };
                }

                state.sets.push({
                    name,
                    elements: new Set(elements),
                    color: Utils.getColorByIndex(state.sets.length)
                });

                clearOperation();
                updateUniversalSet();
                return { success: true, error: null };
            };

            /**
             * Update existing set
             * @param {string} name - Set name
             * @param {Array} elements - New elements
             * @returns {{success: boolean, error: string|null}}
             */
            const updateSet = (name, elements) => {
                const existing = state.sets.find(s => s.name === name);
                if (!existing) {
                    return { success: false, error: 'Set not found' };
                }

                existing.elements = new Set(elements);
                clearOperation();
                updateUniversalSet();
                return { success: true, error: null };
            };

            /**
             * Remove set by index
             * @param {number} index - Set index
             * @returns {{success: boolean, removed: Object|null}}
             */
            const removeSet = (index) => {
                if (index < 0 || index >= state.sets.length) {
                    return { success: false, removed: null };
                }

                const removed = state.sets.splice(index, 1)[0];
                clearOperation();
                updateUniversalSet();
                return { success: true, removed };
            };

            /**
             * Find set by name
             * @param {string} name - Set name
             * @returns {{set: Object|null, index: number}}
             */
            const findSet = (name) => {
                const index = state.sets.findIndex(s => s.name === name);
                return {
                    set: index >= 0 ? state.sets[index] : null,
                    index
                };
            };

            /**
             * Set hovered region
             * @param {Object|null} region - Region data
             */
            const setHoveredRegion = (region) => {
                state.hoveredRegion = region;
            };

            /**
             * Get hovered region
             * @returns {Object|null}
             */
            const getHoveredRegion = () => state.hoveredRegion;

            /**
             * Initialize with example sets
             */
            const initializeDefaultSets = () => {
                state.sets = [
                    {
                        name: 'A',
                        elements: new Set(['1', '2', '3', '4']),
                        color: Utils.getColorByIndex(0)
                    },
                    {
                        name: 'B',
                        elements: new Set(['3', '4', '5', '6']),
                        color: Utils.getColorByIndex(1)
                    }
                ];
                updateUniversalSet();
            };

            return {
                getState,
                getSets,
                getDiagramType,
                setDiagramType,
                updateUniversalSet,
                clearOperation,
                setOperation,
                addSet,
                updateSet,
                removeSet,
                findSet,
                setHoveredRegion,
                getHoveredRegion,
                initializeDefaultSets
            };
        })();

        // ===================================================================
        // PARSER MODULE
        // ===================================================================

        const Parser = (() => {
            /**
             * Parse user input
             * @param {string} input - Raw user input
             * @returns {{type: string, data: Object, error: string|null}}
             */
            const parseInput = (input) => {
                if (!input || !input.trim()) {
                    return { type: 'empty', data: null, error: null };
                }

                // Normalize whitespace
                const normalized = input.trim().replace(CONFIG.REGEX.whitespace, ' ');

                // Try parsing as set definition
                const setDef = parseSetDefinition(normalized);
                if (setDef.type === 'setDefinition') return setDef;

                // Try parsing as complement
                const complement = parseComplement(normalized);
                if (complement.type === 'complement') return complement;

                // Try parsing as binary operation
                const binOp = parseBinaryOperation(normalized);
                if (binOp.type === 'binaryOperation') return binOp;

                return {
                    type: 'invalid',
                    data: null,
                    error: 'invalidSyntax'
                };
            };

            /**
             * Parse set definition (e.g., A={1,2,3})
             * @param {string} input - Normalized input
             * @returns {{type: string, data: Object|null, error: string|null}}
             */
            const parseSetDefinition = (input) => {
                const match = input.match(CONFIG.REGEX.setDefinition);
                if (!match) {
                    return { type: 'notMatched', data: null, error: null };
                }

                const [, name, elementsStr] = match;
                const elements = elementsStr.trim()
                    ? elementsStr.split(',').map(e => e.trim()).filter(e => e.length > 0)
                    : [];

                return {
                    type: 'setDefinition',
                    data: { name, elements },
                    error: null
                };
            };

            /**
             * Parse complement operation (e.g., A' or A̅)
             * @param {string} input - Normalized input
             * @returns {{type: string, data: Object|null, error: string|null}}
             */
            const parseComplement = (input) => {
                const match = input.match(CONFIG.REGEX.complement);
                if (!match) {
                    return { type: 'notMatched', data: null, error: null };
                }

                const [, setName] = match;
                return {
                    type: 'complement',
                    data: { setName },
                    error: null
                };
            };

            /**
             * Parse binary operation (e.g., A ∪ B)
             * @param {string} input - Normalized input
             * @returns {{type: string, data: Object|null, error: string|null}}
             */
            const parseBinaryOperation = (input) => {
                const match = input.match(CONFIG.REGEX.binaryOperation);
                if (!match) {
                    return { type: 'notMatched', data: null, error: null };
                }

                const [, left, op, right] = match;

                // Map operation symbol to type
                let opType;
                if (op === '∪' || op === 'U') opType = 'union';
                else if (op === '∩') opType = 'intersection';
                else if (op === '\\') opType = 'difference';
                else if (op === '△') opType = 'symmetric';

                return {
                    type: 'binaryOperation',
                    data: { left, right, operation: opType, symbol: op === 'U' ? '∪' : op },
                    error: null
                };
            };

            return {
                parseInput,
                parseSetDefinition,
                parseComplement,
                parseBinaryOperation
            };
        })();

        // ===================================================================
        // SET OPERATIONS MODULE
        // ===================================================================

        const SetOps = (() => {
            /**
             * Union of two sets
             * @param {Set} setA - First set
             * @param {Set} setB - Second set
             * @returns {Set} Union result
             */
            const union = (setA, setB) => new Set([...setA, ...setB]);

            /**
             * Intersection of two sets
             * @param {Set} setA - First set
             * @param {Set} setB - Second set
             * @returns {Set} Intersection result
             */
            const intersection = (setA, setB) =>
                new Set([...setA].filter(x => setB.has(x)));

            /**
             * Difference of two sets (A - B)
             * @param {Set} setA - First set
             * @param {Set} setB - Second set
             * @returns {Set} Difference result
             */
            const difference = (setA, setB) =>
                new Set([...setA].filter(x => !setB.has(x)));

            /**
             * Symmetric difference of two sets
             * @param {Set} setA - First set
             * @param {Set} setB - Second set
             * @returns {Set} Symmetric difference result
             */
            const symmetricDifference = (setA, setB) => {
                const diff1 = [...setA].filter(x => !setB.has(x));
                const diff2 = [...setB].filter(x => !setA.has(x));
                return new Set([...diff1, ...diff2]);
            };

            /**
             * Complement of a set relative to universal set
             * @param {Set} set - The set
             * @param {Set} universalSet - Universal set
             * @returns {Set} Complement result
             */
            const complement = (set, universalSet) =>
                new Set([...universalSet].filter(x => !set.has(x)));

            /**
             * Check if two sets intersect
             * @param {Object} setA - Set object with elements property
             * @param {Object} setB - Set object with elements property
             * @returns {boolean}
             */
            const setsIntersect = (setA, setB) => {
                for (const elem of setA.elements) {
                    if (setB.elements.has(elem)) return true;
                }
                return false;
            };

            /**
             * Check if setA is subset of setB
             * @param {Object} setA - Set object with elements property
             * @param {Object} setB - Set object with elements property
             * @returns {boolean}
             */
            const isSubset = (setA, setB) => {
                for (const elem of setA.elements) {
                    if (!setB.elements.has(elem)) return false;
                }
                return true;
            };

            return {
                union,
                intersection,
                difference,
                symmetricDifference,
                complement,
                setsIntersect,
                isSubset
            };
        })();

        // ===================================================================
        // I18N MODULE
        // ===================================================================

        const I18n = (() => {
            let currentLang = localStorage.getItem('language') || 'en';

            /**
             * Get current language
             * @returns {string}
             */
            const getCurrentLanguage = () => currentLang;

            /**
             * Translate a key
             * @param {string} key - Translation key
             * @param {Object} params - Optional parameters for interpolation
             * @returns {string}
             */
            const translate = (key, params = {}) => {
                let text = translations[currentLang]?.[key] || key;

                // Simple parameter replacement
                Object.keys(params).forEach(param => {
                    text = text.replace(`{${param}}`, params[param]);
                });

                return text;
            };

            /**
             * Set language and update UI
             * @param {string} lang - Language code ('en' or 'uk')
             */
            const setLanguage = (lang) => {
                currentLang = lang;
                localStorage.setItem('language', lang);

                // Update language buttons
                document.getElementById('lang-en')?.classList.toggle('active', lang === 'en');
                document.getElementById('lang-uk')?.classList.toggle('active', lang === 'uk');

                // Update all elements with data-i18n attribute
                document.querySelectorAll('[data-i18n]').forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    const text = translate(key);
                    if (element.id === 'examplesContent') {
                        element.innerHTML = text;
                    } else {
                        element.textContent = text;
                    }
                });

                // Update placeholders
                document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
                    const key = element.getAttribute('data-i18n-placeholder');
                    element.placeholder = translate(key);
                });
            };

            return {
                getCurrentLanguage,
                translate,
                setLanguage
            };
        })();

        // ===================================================================
        // APPLICATION CONTROLLER
        // ===================================================================

        const App = (() => {
            // DOM Elements Cache
            const DOM = {
                canvas: null,
                ctx: null,
                tooltip: null,
                statusBar: null,
                inputField: null,
                newSetName: null,
                setList: null
            };

            /**
             * Initialize application
             */
            const init = () => {
                // Cache DOM elements
                DOM.canvas = document.getElementById('vennCanvas');
                DOM.ctx = DOM.canvas.getContext('2d');
                DOM.tooltip = document.getElementById('tooltip');
                DOM.statusBar = document.getElementById('statusBar');
                DOM.inputField = document.getElementById('inputField');
                DOM.newSetName = document.getElementById('newSetName');
                DOM.setList = document.getElementById('setList');

                // Initialize renderer
                Renderer.init(DOM.canvas);

                // Initialize state with default sets
                StateManager.initializeDefaultSets();

                // Setup event listeners
                setupEventListeners();

                // Initial render
                updateSetList();
                resizeCanvas();

                // Initialize language
                I18n.setLanguage(I18n.getCurrentLanguage());
                updateStatusBar(I18n.translate('readyStatus'), CONFIG.STATUS_COLORS.default);
            };

            /**
             * Setup all event listeners
             */
            const setupEventListeners = () => {
                // Resize handler with debouncing
                window.addEventListener('resize', Utils.debounce(resizeCanvas));

                // Input field enter key
                DOM.inputField.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') handleInput();
                });

                // New set name enter key
                DOM.newSetName.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') handleAddEmptySet();
                });

                // Canvas mouse events
                DOM.canvas.addEventListener('mousemove', handleCanvasMouseMove);
                DOM.canvas.addEventListener('mouseleave', handleCanvasMouseLeave);

                // Event delegation for set list (will handle dynamically created elements)
                DOM.setList.addEventListener('click', handleSetListClick);
            };

            /**
             * Handle canvas mouse move
             */
            const handleCanvasMouseMove = (e) => {
                const rect = DOM.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const insideSets = Renderer.getCirclesAtPoint(x, y);

                if (insideSets.length > 0) {
                    const region = Renderer.calculateRegionInfo(insideSets);
                    StateManager.setHoveredRegion({ sets: insideSets, ...region });

                    // Update tooltip
                    DOM.tooltip.textContent = `${region.description}\n${region.elementsText}`;
                    DOM.tooltip.classList.add('visible');

                    // Smart positioning
                    positionTooltip(e, rect);
                } else {
                    StateManager.setHoveredRegion(null);
                    DOM.tooltip.classList.remove('visible');
                }

                Renderer.draw();
            };

            /**
             * Position tooltip smartly to avoid viewport edges
             */
            const positionTooltip = (e, canvasRect) => {
                const rect = DOM.tooltip.getBoundingClientRect();
                const offset = 8;
                const padding = 10;

                let left = canvasRect.left + (e.clientX - canvasRect.left) + offset;
                let top = canvasRect.top + (e.clientY - canvasRect.top) + offset;

                // Check boundaries and flip if needed
                if (left + rect.width + padding > window.innerWidth) {
                    left = canvasRect.left + (e.clientX - canvasRect.left) - rect.width - offset;
                }
                if (top + rect.height + padding > window.innerHeight) {
                    top = canvasRect.top + (e.clientY - canvasRect.top) - rect.height - offset;
                }

                // Clamp to viewport
                left = Math.max(padding, Math.min(left, window.innerWidth - rect.width - padding));
                top = Math.max(padding, Math.min(top, window.innerHeight - rect.height - padding));

                DOM.tooltip.style.left = `${left}px`;
                DOM.tooltip.style.top = `${top}px`;
            };

            /**
             * Handle canvas mouse leave
             */
            const handleCanvasMouseLeave = () => {
                StateManager.setHoveredRegion(null);
                DOM.tooltip.classList.remove('visible');
                Renderer.draw();
            };

            /**
             * Handle set list clicks (event delegation)
             */
            const handleSetListClick = (e) => {
                const setInfo = e.target.closest('.set-info');
                const removeBtn = e.target.closest('.btn-remove');

                if (setInfo) {
                    const index = Array.from(DOM.setList.children).indexOf(setInfo.closest('.set-item'));
                    handleEditSet(index);
                } else if (removeBtn) {
                    const index = Array.from(DOM.setList.children).indexOf(removeBtn.closest('.set-item'));
                    handleRemoveSet(index);
                }
            };

            /**
             * Handle input execution
             */
            const handleInput = () => {
                const input = DOM.inputField.value;
                const parsed = Parser.parseInput(input);

                switch (parsed.type) {
                    case 'empty':
                        return;

                    case 'setDefinition':
                        handleSetDefinition(parsed.data);
                        break;

                    case 'complement':
                        handleComplement(parsed.data);
                        break;

                    case 'binaryOperation':
                        handleBinaryOperation(parsed.data);
                        break;

                    case 'invalid':
                        updateStatusBar(I18n.translate('invalidSyntax'), CONFIG.STATUS_COLORS.error);
                        break;
                }
            };

            /**
             * Handle set definition
             */
            const handleSetDefinition = ({ name, elements }) => {
                const { set } = StateManager.findSet(name);

                if (set) {
                    const result = StateManager.updateSet(name, elements);
                    if (result.success) {
                        updateStatusBar(
                            `${I18n.translate('updatedSet')} ${name}`,
                            CONFIG.STATUS_COLORS.success
                        );
                    }
                } else {
                    const result = StateManager.addSet(name, elements);
                    if (result.success) {
                        updateStatusBar(
                            `${I18n.translate('createdSet')} ${name}`,
                            CONFIG.STATUS_COLORS.success
                        );
                    } else {
                        updateStatusBar(I18n.translate('maxSets'), CONFIG.STATUS_COLORS.error);
                        return;
                    }
                }

                DOM.inputField.value = '';
                updateSetList();
                Renderer.draw();
            };

            /**
             * Handle complement operation
             */
            const handleComplement = ({ setName }) => {
                const { set, index } = StateManager.findSet(setName);

                if (!set) {
                    updateStatusBar(
                        `${setName} ${I18n.translate('setNotDefined')} ${setName}={...}`,
                        CONFIG.STATUS_COLORS.error
                    );
                    return;
                }

                const state = StateManager.getState();
                const result = SetOps.complement(set.elements, state.universalSet);
                const description = `${setName}\u0305 = {${Array.from(result).join(', ')}}`;

                StateManager.setOperation(
                    { type: 'complement', leftSet: index, rightSet: null },
                    result,
                    description
                );

                updateStatusBar(description, CONFIG.STATUS_COLORS.info);
                Renderer.draw();
            };

            /**
             * Handle binary operation
             */
            const handleBinaryOperation = ({ left, right, operation, symbol }) => {
                const leftResult = StateManager.findSet(left);
                const rightResult = StateManager.findSet(right);

                // Check if sets exist
                if (!leftResult.set && !rightResult.set) {
                    updateStatusBar(
                        `${left}, ${right} ${I18n.translate('setsNotDefined')}`,
                        CONFIG.STATUS_COLORS.error
                    );
                    return;
                }
                if (!leftResult.set) {
                    updateStatusBar(
                        `${left} ${I18n.translate('setNotDefined')} ${left}={...}`,
                        CONFIG.STATUS_COLORS.error
                    );
                    return;
                }
                if (!rightResult.set) {
                    updateStatusBar(
                        `${right} ${I18n.translate('setNotDefined')} ${right}={...}`,
                        CONFIG.STATUS_COLORS.error
                    );
                    return;
                }

                // Perform operation
                let result;
                switch (operation) {
                    case 'union':
                        result = SetOps.union(leftResult.set.elements, rightResult.set.elements);
                        break;
                    case 'intersection':
                        result = SetOps.intersection(leftResult.set.elements, rightResult.set.elements);
                        break;
                    case 'difference':
                        result = SetOps.difference(leftResult.set.elements, rightResult.set.elements);
                        break;
                    case 'symmetric':
                        result = SetOps.symmetricDifference(leftResult.set.elements, rightResult.set.elements);
                        break;
                }

                const description = `${left} ${symbol} ${right} = {${Array.from(result).join(', ')}}`;

                StateManager.setOperation(
                    { type: operation, leftSet: leftResult.index, rightSet: rightResult.index },
                    result,
                    description
                );

                updateStatusBar(description, CONFIG.STATUS_COLORS.info);
                Renderer.draw();
            };

            /**
             * Handle add empty set
             */
            const handleAddEmptySet = () => {
                const name = DOM.newSetName.value.trim();
                if (!name) return;

                const result = StateManager.addSet(name, []);

                if (result.success) {
                    DOM.newSetName.value = '';
                    updateSetList();
                    Renderer.draw();
                    updateStatusBar(
                        `${I18n.translate('addedEmptySet')} ${name}`,
                        CONFIG.STATUS_COLORS.success
                    );
                } else {
                    if (result.error.includes('exists')) {
                        updateStatusBar(I18n.translate('setNameExists'), CONFIG.STATUS_COLORS.error);
                    } else {
                        updateStatusBar(I18n.translate('maxSets'), CONFIG.STATUS_COLORS.error);
                    }
                }
            };

            /**
             * Handle edit set
             */
            const handleEditSet = (index) => {
                const sets = StateManager.getSets();
                const set = sets[index];
                if (!set) return;

                const elementsArray = Array.from(set.elements);
                DOM.inputField.value = `${set.name}={${elementsArray.join(',')}}`;
                DOM.inputField.focus();
            };

            /**
             * Handle remove set
             */
            const handleRemoveSet = (index) => {
                const result = StateManager.removeSet(index);
                if (result.success) {
                    updateSetList();
                    Renderer.draw();
                    updateStatusBar(
                        `${I18n.translate('removedSet')} ${result.removed.name}`,
                        CONFIG.STATUS_COLORS.warning
                    );
                }
            };

            /**
             * Handle diagram type change
             */
            const handleDiagramTypeChange = (type) => {
                StateManager.setDiagramType(type);
                Renderer.draw();
            };

            /**
             * Handle insert operation
             */
            const handleInsertOperation = (type) => {
                let currentValue = DOM.inputField.value.trim();

                if (type === 'complement') {
                    DOM.inputField.value = currentValue + CONFIG.OPERATION_SYMBOLS.complement;
                } else {
                    const symbol = CONFIG.OPERATION_SYMBOLS[type];
                    if (currentValue && !currentValue.endsWith(' ')) {
                        currentValue += ' ';
                    }
                    DOM.inputField.value = currentValue + symbol + ' ';
                }

                DOM.inputField.focus();
            };

            /**
             * Handle language change
             */
            const handleLanguageChange = (lang) => {
                I18n.setLanguage(lang);
                updateStatusBar(I18n.translate('readyStatus'), CONFIG.STATUS_COLORS.default);
                Renderer.draw();
            };

            /**
             * Resize canvas
             */
            const resizeCanvas = () => {
                const container = DOM.canvas.parentElement;
                DOM.canvas.width = container.clientWidth;
                DOM.canvas.height = container.clientHeight;
                Renderer.draw();
            };

            /**
             * Update set list display
             */
            const updateSetList = () => {
                DOM.setList.innerHTML = '';
                const sets = StateManager.getSets();

                sets.forEach((set, index) => {
                    const li = document.createElement('li');
                    li.className = 'set-item';

                    const elementsArray = Array.from(set.elements);
                    const elementsStr = Utils.formatElementList(elementsArray);

                    // Create elements safely without inline handlers
                    const setColor = document.createElement('div');
                    setColor.className = 'set-color';
                    setColor.style.background = Utils.formatRgbColor(set.color);

                    const setInfo = document.createElement('div');
                    setInfo.className = 'set-info';
                    setInfo.style.cursor = 'pointer';

                    const setName = document.createElement('div');
                    setName.className = 'set-name';
                    setName.textContent = `${set.name} = ${elementsStr}`;

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn-remove';
                    removeBtn.textContent = '×';

                    setInfo.appendChild(setName);
                    li.appendChild(setColor);
                    li.appendChild(setInfo);
                    li.appendChild(removeBtn);
                    DOM.setList.appendChild(li);
                });
            };

            /**
             * Update status bar
             */
            const updateStatusBar = (message, color) => {
                DOM.statusBar.textContent = message;
                DOM.statusBar.style.color = color;
            };

            // Export global functions for HTML onclick handlers (will migrate to event delegation)
            window.changeDiagramType = handleDiagramTypeChange;
            window.insertOperation = handleInsertOperation;
            window.setLanguage = handleLanguageChange;
            window.executeInput = handleInput;
            window.addEmptySet = handleAddEmptySet;
            window.editSet = handleEditSet;
            window.removeSet = handleRemoveSet;

            return {
                init
            };
        })();

        /**
         * Renderer Module
         * Handles all canvas drawing operations for Venn/Euler diagrams
         * @module Renderer
         */
        const Renderer = (() => {
            let ctx = null;
            let canvas = null;

            /**
             * Initialize renderer with canvas context
             * @param {HTMLCanvasElement} canvasElement - The canvas element
             */
            const init = (canvasElement) => {
                canvas = canvasElement;
                ctx = canvas.getContext('2d');
            };

            /**
             * Main drawing function - orchestrates the entire diagram rendering
             */
            const draw = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const state = StateManager.getState();

                if (state.sets.length === 0) {
                    drawEmptyMessage();
                    return;
                }

                const circles = calculateCirclePositions();

                // Draw universal set rectangle
                drawUniversalSet(circles);

                // If there's an operation, draw regions with proper highlighting
                if (state.currentOperation) {
                    drawOperationHighlight(circles);
                } else {
                    drawCircles(circles);
                }

                // Draw elements in regions
                if (state.sets.length === 2) {
                    drawTwoSetElements(circles);
                } else if (state.sets.length === 3) {
                    drawThreeSetElements(circles);
                }
            };

            /**
             * Draw message when no sets are defined
             */
            const drawEmptyMessage = () => {
                ctx.fillStyle = '#6b7280';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(
                    'No sets defined. Add a set to get started!',
                    canvas.width / 2,
                    canvas.height / 2
                );
            };

            /**
             * Draw circles with strokes and labels
             * @param {Array<Object>} circles - Circle definitions
             */
            const drawCircles = (circles) => {
                circles.forEach(circle => {
                    ctx.strokeStyle = Utils.formatRgbColor(circle.color);
                    ctx.lineWidth = CONFIG.LINE_WIDTH.default;
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, circle.r, 0, Math.PI * 2);
                    ctx.stroke();

                    // Draw label
                    ctx.fillStyle = Utils.formatRgbColor(circle.color);
                    ctx.font = CONFIG.FONT_SIZE.label;
                    ctx.textAlign = 'center';
                    ctx.fillText(circle.name, circle.x, circle.y - circle.r - 10);
                });
            };

            /**
             * Draw universal set rectangle around circles
             * @param {Array<Object>} circles - Circle definitions
             */
            const drawUniversalSet = (circles) => {
                if (circles.length === 0) return;

                // Calculate bounding box for all circles
                let minX = Math.min(...circles.map(c => c.x - c.r));
                let maxX = Math.max(...circles.map(c => c.x + c.r));
                let minY = Math.min(...circles.map(c => c.y - c.r));
                let maxY = Math.max(...circles.map(c => c.y + c.r));

                // Add padding
                minX -= CONFIG.CANVAS_PADDING;
                maxX += CONFIG.CANVAS_PADDING;
                minY -= CONFIG.CANVAS_PADDING;
                maxY += CONFIG.CANVAS_PADDING;

                // Draw rectangle
                ctx.strokeStyle = '#9ca3af';
                ctx.lineWidth = CONFIG.LINE_WIDTH.default;
                ctx.setLineDash([8, 4]);
                ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
                ctx.setLineDash([]); // Reset dash

                // Draw label "U" in top-left corner
                ctx.fillStyle = '#6b7280';
                ctx.font = CONFIG.FONT_SIZE.label;
                ctx.textAlign = 'left';
                ctx.fillText('U', minX + 10, minY + 25);
            };

            /**
             * Draw diagonal hatching pattern for operation results
             * @param {string} color - RGB color string
             * @param {number} spacing - Spacing between hatch lines
             * @param {number} lineWidth - Width of hatch lines
             */
            const drawDiagonalHatching = (color, spacing = CONFIG.HATCHING_SPACING, lineWidth = CONFIG.LINE_WIDTH.diagonal) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;

                const width = canvas.width;
                const height = canvas.height;
                const maxDim = width + height;

                // Draw diagonal lines from top-left to bottom-right
                for (let i = -maxDim; i < maxDim; i += spacing) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + height, height);
                    ctx.stroke();
                }
            };

            /**
             * Draw operation highlighting using hatching patterns
             * @param {Array<Object>} circles - Circle definitions
             */
            const drawOperationHighlight = (circles) => {
                // First, draw all circles with strokes only (no fill)
                drawCircles(circles);

                const state = StateManager.getState();
                if (!state.currentOperation) return;

                const { type, leftSet, rightSet } = state.currentOperation;
                const circleA = circles[leftSet];
                const circleB = rightSet !== null ? circles[rightSet] : null;

                ctx.save();

                switch (type) {
                    case 'union':
                        drawUnionHighlight(circleA, circleB);
                        break;
                    case 'intersection':
                        drawIntersectionHighlight(circleA, circleB);
                        break;
                    case 'difference':
                        drawDifferenceHighlight(circleA, circleB);
                        break;
                    case 'symmetric':
                        drawSymmetricDifferenceHighlight(circleA, circleB);
                        break;
                    case 'complement':
                        drawComplementHighlight(circleA, circles);
                        break;
                }

                ctx.restore();
            };

            /**
             * Draw union operation highlighting
             */
            const drawUnionHighlight = (circleA, circleB) => {
                ctx.beginPath();
                ctx.arc(circleA.x, circleA.y, circleA.r, 0, Math.PI * 2);
                ctx.arc(circleB.x, circleB.y, circleB.r, 0, Math.PI * 2);
                ctx.clip();
                drawDiagonalHatching(CONFIG.OPERATION_COLORS.union);
            };

            /**
             * Draw intersection operation highlighting
             */
            const drawIntersectionHighlight = (circleA, circleB) => {
                ctx.beginPath();
                ctx.arc(circleA.x, circleA.y, circleA.r, 0, Math.PI * 2);
                ctx.clip();
                ctx.beginPath();
                ctx.arc(circleB.x, circleB.y, circleB.r, 0, Math.PI * 2);
                ctx.clip();
                drawDiagonalHatching(CONFIG.OPERATION_COLORS.intersection);
            };

            /**
             * Draw difference operation highlighting
             */
            const drawDifferenceHighlight = (circleA, circleB) => {
                ctx.beginPath();
                ctx.arc(circleA.x, circleA.y, circleA.r, 0, Math.PI * 2);
                ctx.clip();
                // Create a temporary canvas for cutting out circleB
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(circleB.x, circleB.y, circleB.r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                // Now hatch the remaining area
                ctx.beginPath();
                ctx.arc(circleA.x, circleA.y, circleA.r, 0, Math.PI * 2);
                ctx.clip();
                drawDiagonalHatching(CONFIG.OPERATION_COLORS.difference);
            };

            /**
             * Draw symmetric difference operation highlighting
             */
            const drawSymmetricDifferenceHighlight = (circleA, circleB) => {
                ctx.beginPath();
                ctx.arc(circleA.x, circleA.y, circleA.r, 0, Math.PI * 2);
                ctx.arc(circleB.x, circleB.y, circleB.r, 0, Math.PI * 2);
                ctx.clip();
                drawDiagonalHatching(CONFIG.OPERATION_COLORS.symmetric);

                // Cut out the intersection
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(circleA.x, circleA.y, circleA.r, 0, Math.PI * 2);
                ctx.clip();
                ctx.beginPath();
                ctx.arc(circleB.x, circleB.y, circleB.r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            };

            /**
             * Draw complement operation highlighting
             */
            const drawComplementHighlight = (circleA, circles) => {
                const minX = Math.min(...circles.map(c => c.x - c.r)) - CONFIG.CANVAS_PADDING;
                const maxX = Math.max(...circles.map(c => c.x + c.r)) + CONFIG.CANVAS_PADDING;
                const minY = Math.min(...circles.map(c => c.y - c.r)) - CONFIG.CANVAS_PADDING;
                const maxY = Math.max(...circles.map(c => c.y + c.r)) + CONFIG.CANVAS_PADDING;

                ctx.rect(minX, minY, maxX - minX, maxY - minY);
                ctx.clip();
                drawDiagonalHatching(CONFIG.OPERATION_COLORS.complement);

                // Cut out the circle
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(circleA.x, circleA.y, circleA.r, 0, Math.PI * 2);
                ctx.fill();
            };

            /**
             * Calculate circle positions based on current state
             * @returns {Array<Object>} Array of circle definitions
             */
            const calculateCirclePositions = () => {
                const state = StateManager.getState();
                const centerX = canvas.width / 2;
                const centerY = (canvas.height - 60) / 2; // Leave space for status bar
                const radius = Math.min(canvas.width, canvas.height - 120) / 4;

                if (state.sets.length === 1) {
                    return [{
                        x: centerX,
                        y: centerY,
                        r: radius,
                        name: state.sets[0].name,
                        color: state.sets[0].color
                    }];
                }

                if (state.sets.length === 2) {
                    return calculateTwoSetPositions(centerX, centerY, radius);
                }

                if (state.sets.length === 3) {
                    return calculateThreeSetPositions(centerX, centerY, radius);
                }

                if (state.sets.length === 4) {
                    return calculateFourSetPositions(centerX, centerY, radius);
                }

                return [];
            };

            /**
             * Calculate positions for two sets
             */
            const calculateTwoSetPositions = (centerX, centerY, radius) => {
                const state = StateManager.getState();
                const setA = state.sets[0];
                const setB = state.sets[1];

                // For Euler diagrams, handle special cases
                if (state.diagramType === 'euler') {
                    const aSubsetB = SetOps.isSubset(setA, setB);
                    const bSubsetA = SetOps.isSubset(setB, setA);

                    if (aSubsetB && bSubsetA) {
                        // Equal sets - draw as single overlapping circle
                        return [
                            { x: centerX, y: centerY, r: radius, name: setA.name, color: setA.color },
                            { x: centerX, y: centerY, r: radius, name: setB.name, color: setB.color }
                        ];
                    } else if (bSubsetA) {
                        // B ⊂ A: B inside A
                        return [
                            { x: centerX, y: centerY, r: radius, name: setA.name, color: setA.color },
                            { x: centerX, y: centerY, r: radius * 0.6, name: setB.name, color: setB.color }
                        ];
                    } else if (aSubsetB) {
                        // A ⊂ B: A inside B
                        return [
                            { x: centerX, y: centerY, r: radius * 0.6, name: setA.name, color: setA.color },
                            { x: centerX, y: centerY, r: radius, name: setB.name, color: setB.color }
                        ];
                    } else if (!SetOps.setsIntersect(setA, setB)) {
                        // Disjoint sets - separate circles
                        const offset = radius * 2.2;
                        return [
                            { x: centerX - offset, y: centerY, r: radius, name: setA.name, color: setA.color },
                            { x: centerX + offset, y: centerY, r: radius, name: setB.name, color: setB.color }
                        ];
                    }
                }

                // Default Venn diagram or Euler with partial overlap
                const offset = radius * 0.7;
                return [
                    { x: centerX - offset, y: centerY, r: radius, name: setA.name, color: setA.color },
                    { x: centerX + offset, y: centerY, r: radius, name: setB.name, color: setB.color }
                ];
            };

            /**
             * Calculate positions for three sets
             */
            const calculateThreeSetPositions = (centerX, centerY, radius) => {
                const state = StateManager.getState();
                const sets = state.sets;

                if (state.diagramType === 'euler') {
                    const ab = SetOps.setsIntersect(sets[0], sets[1]);
                    const ac = SetOps.setsIntersect(sets[0], sets[2]);
                    const bc = SetOps.setsIntersect(sets[1], sets[2]);

                    // If no intersections at all, arrange in a line
                    if (!ab && !ac && !bc) {
                        return [
                            { x: centerX - radius * 2.5, y: centerY, r: radius, name: sets[0].name, color: sets[0].color },
                            { x: centerX, y: centerY, r: radius, name: sets[1].name, color: sets[1].color },
                            { x: centerX + radius * 2.5, y: centerY, r: radius, name: sets[2].name, color: sets[2].color }
                        ];
                    }
                }

                // Standard Venn layout
                const offset = radius * 0.7;
                return [
                    { x: centerX - offset, y: centerY - offset * 0.5, r: radius, name: sets[0].name, color: sets[0].color },
                    { x: centerX + offset, y: centerY - offset * 0.5, r: radius, name: sets[1].name, color: sets[1].color },
                    { x: centerX, y: centerY + offset * 0.7, r: radius, name: sets[2].name, color: sets[2].color }
                ];
            };

            /**
             * Calculate positions for four sets
             */
            const calculateFourSetPositions = (centerX, centerY, radius) => {
                const state = StateManager.getState();
                const sets = state.sets;

                if (state.diagramType === 'euler') {
                    // Check all pairwise intersections
                    const intersections = [
                        SetOps.setsIntersect(sets[0], sets[1]),
                        SetOps.setsIntersect(sets[0], sets[2]),
                        SetOps.setsIntersect(sets[0], sets[3]),
                        SetOps.setsIntersect(sets[1], sets[2]),
                        SetOps.setsIntersect(sets[1], sets[3]),
                        SetOps.setsIntersect(sets[2], sets[3])
                    ];

                    // If no intersections at all, arrange in a 2x2 grid with separation
                    if (!intersections.some(Boolean)) {
                        const offset = radius * 2.5;
                        return [
                            { x: centerX - offset, y: centerY - offset, r: radius, name: sets[0].name, color: sets[0].color },
                            { x: centerX + offset, y: centerY - offset, r: radius, name: sets[1].name, color: sets[1].color },
                            { x: centerX - offset, y: centerY + offset, r: radius, name: sets[2].name, color: sets[2].color },
                            { x: centerX + offset, y: centerY + offset, r: radius, name: sets[3].name, color: sets[3].color }
                        ];
                    }
                }

                // Standard Venn layout
                const offset = radius * 0.6;
                return [
                    { x: centerX - offset, y: centerY - offset, r: radius, name: sets[0].name, color: sets[0].color },
                    { x: centerX + offset, y: centerY - offset, r: radius, name: sets[1].name, color: sets[1].color },
                    { x: centerX - offset, y: centerY + offset, r: radius, name: sets[2].name, color: sets[2].color },
                    { x: centerX + offset, y: centerY + offset, r: radius, name: sets[3].name, color: sets[3].color }
                ];
            };

            /**
             * Draw elements for two-set diagram
             * @param {Array<Object>} circles - Circle definitions
             */
            const drawTwoSetElements = (circles) => {
                const state = StateManager.getState();
                const setA = state.sets[0];
                const setB = state.sets[1];

                // Check if circles are nested (same center, different radii)
                const isNested = circles[0].x === circles[1].x &&
                                circles[0].y === circles[1].y &&
                                circles[0].r !== circles[1].r;

                if (isNested) {
                    // Nested circles - one set is subset of another
                    const outerCircle = circles[0].r > circles[1].r ? circles[0] : circles[1];
                    const innerCircle = circles[0].r > circles[1].r ? circles[1] : circles[0];
                    const outerSet = circles[0].r > circles[1].r ? setA : setB;
                    const innerSet = circles[0].r > circles[1].r ? setB : setA;

                    // Elements only in outer set (the ring)
                    const outerOnly = SetOps.difference(outerSet.elements, innerSet.elements);
                    const ringRadius = (outerCircle.r + innerCircle.r) / 2;
                    drawElementList(Array.from(outerOnly), outerCircle.x, outerCircle.y - ringRadius * 0.5);

                    // All elements of inner set (it's completely inside outer)
                    drawElementList(Array.from(innerSet.elements), innerCircle.x, innerCircle.y);
                } else {
                    // Side-by-side circles (standard Venn)
                    // A only
                    const aOnly = SetOps.difference(setA.elements, setB.elements);
                    drawElementList(Array.from(aOnly), circles[0].x - circles[0].r * 0.4, circles[0].y);

                    // A ∩ B
                    const intersection = SetOps.intersection(setA.elements, setB.elements);
                    drawElementList(
                        Array.from(intersection),
                        (circles[0].x + circles[1].x) / 2,
                        (circles[0].y + circles[1].y) / 2
                    );

                    // B only
                    const bOnly = SetOps.difference(setB.elements, setA.elements);
                    drawElementList(Array.from(bOnly), circles[1].x + circles[1].r * 0.4, circles[1].y);
                }
            };

            /**
             * Draw elements for three-set diagram
             * @param {Array<Object>} circles - Circle definitions
             */
            const drawThreeSetElements = (circles) => {
                const state = StateManager.getState();
                const setA = state.sets[0];
                const setB = state.sets[1];
                const setC = state.sets[2];

                // A only
                const aOnly = Array.from(setA.elements).filter(
                    x => !setB.elements.has(x) && !setC.elements.has(x)
                );
                drawElementList(aOnly, circles[0].x - circles[0].r * 0.5, circles[0].y - circles[0].r * 0.3);

                // B only
                const bOnly = Array.from(setB.elements).filter(
                    x => !setA.elements.has(x) && !setC.elements.has(x)
                );
                drawElementList(bOnly, circles[1].x + circles[1].r * 0.5, circles[1].y - circles[1].r * 0.3);

                // C only
                const cOnly = Array.from(setC.elements).filter(
                    x => !setA.elements.has(x) && !setB.elements.has(x)
                );
                drawElementList(cOnly, circles[2].x, circles[2].y + circles[2].r * 0.5);

                // A ∩ B only
                const abOnly = Array.from(setA.elements).filter(
                    x => setB.elements.has(x) && !setC.elements.has(x)
                );
                drawElementList(
                    abOnly,
                    (circles[0].x + circles[1].x) / 2,
                    (circles[0].y + circles[1].y) / 2 - circles[0].r * 0.3
                );

                // A ∩ C only
                const acOnly = Array.from(setA.elements).filter(
                    x => setC.elements.has(x) && !setB.elements.has(x)
                );
                drawElementList(
                    acOnly,
                    (circles[0].x + circles[2].x) / 2 - circles[0].r * 0.2,
                    (circles[0].y + circles[2].y) / 2
                );

                // B ∩ C only
                const bcOnly = Array.from(setB.elements).filter(
                    x => setC.elements.has(x) && !setA.elements.has(x)
                );
                drawElementList(
                    bcOnly,
                    (circles[1].x + circles[2].x) / 2 + circles[1].r * 0.2,
                    (circles[1].y + circles[2].y) / 2
                );

                // A ∩ B ∩ C
                const abc = Array.from(setA.elements).filter(
                    x => setB.elements.has(x) && setC.elements.has(x)
                );
                drawElementList(
                    abc,
                    (circles[0].x + circles[1].x + circles[2].x) / 3,
                    (circles[0].y + circles[1].y + circles[2].y) / 3
                );
            };

            /**
             * Draw list of elements at specified position
             * @param {Array<string>} elements - Elements to display
             * @param {number} x - X coordinate
             * @param {number} y - Y coordinate
             */
            const drawElementList = (elements, x, y) => {
                let text;
                if (elements.length === 0) {
                    text = '∅';
                } else if (elements.length <= CONFIG.ELEMENT_DISPLAY_THRESHOLD) {
                    text = elements.join(', ');
                } else {
                    text = `${elements.length} elem`;
                }

                ctx.fillStyle = '#374151';
                ctx.font = CONFIG.FONT_SIZE.element;
                ctx.textAlign = 'center';
                ctx.fillText(text, x, y);
            };

            /**
             * Calculate region info for tooltip
             * @param {Array<number>} insideSets - Indices of sets the point is inside
             * @returns {Object} Region description and elements
             */
            const calculateRegionInfo = (insideSets) => {
                const state = StateManager.getState();

                // Get all elements that are in all the inside sets
                let elements = new Set(state.sets[insideSets[0]].elements);
                for (let i = 1; i < insideSets.length; i++) {
                    elements = SetOps.intersection(elements, state.sets[insideSets[i]].elements);
                }

                // Remove elements that are in sets we're NOT inside
                for (let i = 0; i < state.sets.length; i++) {
                    if (!insideSets.includes(i)) {
                        elements = SetOps.difference(elements, state.sets[i].elements);
                    }
                }

                const elementsArray = Array.from(elements);
                const elementsText = elementsArray.length === 0 ? '∅ (empty)' :
                                     elementsArray.length <= CONFIG.ELEMENT_DISPLAY_THRESHOLD ? `{${elementsArray.join(', ')}}` :
                                     `${elementsArray.length} elements`;

                let description;
                if (insideSets.length === 1) {
                    description = state.sets.length > 1 ?
                        `${state.sets[insideSets[0]].name} ${I18n.translate('only')}` :
                        state.sets[insideSets[0]].name;
                } else {
                    description = insideSets.map(i => state.sets[i].name).join(' ∩ ');
                }

                return { description, elementsText };
            };

            /**
             * Get circles currently inside point (for hover detection)
             * @param {number} x - X coordinate
             * @param {number} y - Y coordinate
             * @returns {Array<number>} Indices of circles containing the point
             */
            const getCirclesAtPoint = (x, y) => {
                const circles = calculateCirclePositions();
                const insideSets = [];

                circles.forEach((circle, idx) => {
                    if (Utils.isPointInCircle(x, y, circle)) {
                        insideSets.push(idx);
                    }
                });

                return insideSets;
            };

            return {
                init,
                draw,
                calculateRegionInfo,
                getCirclesAtPoint
            };
        })();

        // Initialize application when DOM is ready
        App.init();
    </script>
</body>
</html>
